# OOP



## 构造函数模式

```javascript
function fn() {
    
}
new fn();

/*
	自变量表达式
	构造函数模式
*/

var ob1 = {}
var obj1 = new Object();


var num1 = 1;
var num2 = new Number(12)
// 基本类型创建的形式是不一样的
```



## 构造函数执行机制

```javascript
/*
	普通函数执行
	1. 形成一个私有的作用域
	2. 形参赋值
	3. 变量提升
	4. 代码执行
	5. 栈内存释放问题
*/

/*
	构造函数执行
	1. 私有作用域
	2. 参数赋值和变量提升
	3. 创建一个对象 函数执行的this指向这个对象
	4. 代码执行
	5. 代码执行完成 堆内存的地址返回（浏览器默认返回）
	6. 开始创建的实例就是fn的一个实例 然后返回示例
	7. 如果内部返回了一个引用类型的数据 返回时引用类型的地址值
*/
```



## instanceof

```javascript
f instanceof Fn;
in 检测一个对象有没有某个属性
hasOwnProperty() // 私有属性
```



## 原型和原型链的机制

```javascript
/*
	原型 prototype
	原型链 __proto__
*/

/*
	很重要
*/
1. 所有的函数都以一个属性 prototype 对象属性 默认开辟一个堆内存
2. prototype默认由于属性 默认指向了当前的函数本身
3. 每一个`对象`都有一个__proto__ 属性 这个属性指向当前实例所属类的原型(prototype)
```

