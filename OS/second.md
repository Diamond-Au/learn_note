# 进程管理



## 前趋图

+ 分析程序的执行过程， 分析哪些可以并行，哪些应该顺序执行
+ 杜绝循环的存在



## 程序的顺序执行

+ 顺序性
+ 封闭性 程序独占整机资源 
+ 可再现性



## 程序并发执行

###### 间断性 

+ 执行-暂停执行-执行 你即将使用得资源可能别的进程正在使用，你需要等待

###### 失去了封闭性

+ 系统资源的资源是共享的，就只去了封闭性，自己运行的程序可能会受到别的程序的影响

###### 不可再现性

+ 并发的程序，结果是不可再现的
+ 如果采取了某些措施就是可以再现的



## 进程的定义和特征

```txt
为了使得程序执行可以并发执行，而且要保持其的可再现性，就引入了进程的概念。 基于程序的概念已经不能完整有效的描述内存中的运行状态，就要建立起新的， 基于并发程序的一种动态的描述机制。
进程  程序段 数据段 进程控制块
进程控制块就是记录了一些动态的数据 进程的标识符 进程的运行状态 数据地址等一些CPU的环境信息
```

+ 进程是系统进行资源分配和调度的一个独立单位（数据集上运行过程）
+ 有进程控制块
+ 推进的速度无法预知



## 进程的基本的状态和状态转换

### 挂起状态

![image-20201008213318061](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201008213318061.png)

### unix 进程状态转换图

![image-20201008213831508](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201008213831508.png)

### Linux进程状态转换

![image-20201008214736363](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201008214736363.png)





## 进程控制 

### 进程控制块

+ 进程实体的一部分 记录着进程情况和控制进程的全部信息
+ 正是由于有了PCB， 程序才可以有`再现性` 和 `并发性`
+ 进程控制块是存在的唯一标志
+ 常驻在内存专门开辟的PCB区

### 进程控制块的信息

+ 进程标识符（操作系统识别进程 父子进程互相识别）
+ 处理器状态信息 （操作系统的中断）
+ 进程调度的信息（进程状态  优先级 事件）
+ 控制信息 （资源的地址， 程序和数据的地址。。。）

描述了信息为的是可以更好地父进程管理子进程



![image-20201014231550003](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201014231550003.png)



![image-20201014231737096](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201014231737096.png)

![image-20201014231942447](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201014231942447.png)



### 进程的创建和终止

+ 作业调度
+ 用户登录
+ 提供服务
+ 应用请求

#### create()原语

+ 先分配标识符， 申请一块空白的进程控制快
+ 给新的程序或者数据分配空间 用户栈和系统栈
+ 初始化进程控制快 （自身和父进程的控制块 处理器状态 优先级。。。）
+ 加入到就绪状态

#### Terminate()原语

+ 检索PCB 读取他的状态
+ 如果执行应该终止执行，标记调度状态为真，来调度新的进程
+ 终止子孙进程
+ 资源回收
+ 进入终止进程队列 （PCB还在保存）