## 图形化用户接口

+ 同屏和多窗口和并发进程相对应

+ 支持即时交互

### 实现机制

+ 面向对象设施
+ 消息产生， 传递和处理
+ 事件驱动模式

![image-20201005212218889](https://cdn.jsdelivr.net/gh/Diamond-Au/image/images/image-20201005212218889.png)



### 系统调用（操作系统内核提供的服务于程序级的命令）

+ 运行在不同的系统状态（用户态---> 系统态）
+ 服务于用户要访问系统资源
+ 软中断的进入机制
+ 返回集重新调度问题
+ 支持嵌套调用



### 系统调用举例

+ 文件读取，拷贝到另一个文件

  > 源文件打开  目标文件创建 文件数据读进缓冲 缓冲输出到目标文件 关闭数据文件

+ 都会用户态 ---> 系统态
+ 间接调用

```c++
#include <fcntl.h>
#define O_RDONLY 00
#define O_RW 0666
int main(int argc, chat * argv[])
{
  int fdOld, fdNew, count;
  char buffer[2048];
  fdOld = open(argv[1], O_RDONLY);
  fdNew = creat(argv[2], O_RW);
  while(count = read(fdOld, buffer, sizeof(buffer)))
  {
    write(fdNew, buffer, count);
  }
  close(fdOld);
  close(fdNew);
}
```

+ 直接调用

```c++
#include<unistd.h>
#include <sys/syscall.h>
#define O_RDONLY 00
#define O_RW 0666
int mian(int argc, char * argv[])
{
  int fdOld, fdNew, count;
  char buffer[2048];
  fdOld = syscall(SYS_open, argv[1], O_RDONLY);
  fdNew = syscall(SYS_creat, argv[2], 0666);
  while(count = syscall(SYS_read, fdOld, buffer, sizeof(buffer)))
  {
    syscall(SYS_write, fdNew, buffer, count);
  }
  syscall(SYS_close, fdOld);
  syscall(SYS_close, fdNew);
}
// SYS_open 系统调用号
// syscall()  系统调用入口 
```

![image-20201005214657593](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201005214657593.png)



+ 系统调用一般的处理

> 处理机的状态由用户态 ----> 系统态
>
> 保护CPU现场 将PSW, PC 系统调用号， 用户栈指针， 通用寄存器压入堆栈
>
> 用户的参数送到指定的位置
>
> 中断表和陷入向量表



## 操作系统引导(启动模块)

![image-20201005223006371](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201005223006371.png)

ROM BIOS 自检， 然后调用19中断转入引导程序



##### 系统启动过程

机器加电 ---> BIOS 加电自检 进行硬件检测 --->  读入启动盘的引导扇区 512字节到内存 0000:7C00出 ----> 检查内存0000:7DFE~7DFF 是否为0x55AA ---> 跳转到0000:7C00执行引导记录程序

##### 引导扇区

末字节为0x55AA

#### 操作系统二次加载引导程序

BIOS加载引导程序 --> 引导程序加载内核的代码

##### 二次加载

+ BIOS将引导程序载入内存执行
+ 引导程序讲操作系统载入内存
+ 软驱的复位和读取 (读取的内核代码) BIOS INT 13H 
+ BIOS INT 10H 字符串的显示

注：$程序的当前地址 $$ 程序的起始地址



## 操作系统的发展动力

+ 硬件（提高资源利用率和系统性能）
+ 方便用户
+ 适应器件的更新的换代
+ 计算机的体系结构不断发展

### 发展

+ 人工阶段 纸带/卡片 机器语言 拥堵独占 资源利用率低 CPU大量时间空闲
+ 为了解决人机矛盾  通道技术 中断技术 缓冲技术 脱机输入输出 批处理技术