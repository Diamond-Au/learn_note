## 图形化用户接口

+ 同屏和多窗口和并发进程相对应

+ 支持即时交互

### 实现机制

+ 面向对象设施
+ 消息产生， 传递和处理
+ 事件驱动模式

![image-20201005212218889](https://cdn.jsdelivr.net/gh/Diamond-Au/image/images/image-20201005212218889.png)



### 系统调用（操作系统内核提供的服务于程序级的命令）

+ 运行在不同的系统状态（用户态---> 系统态）
+ 服务于用户要访问系统资源
+ 软中断的进入机制
+ 返回集重新调度问题
+ 支持嵌套调用



### 系统调用举例

+ 文件读取，拷贝到另一个文件

  > 源文件打开  目标文件创建 文件数据读进缓冲 缓冲输出到目标文件 关闭数据文件

+ 都会用户态 ---> 系统态
+ 间接调用

```c++
#include <fcntl.h>
#define O_RDONLY 00
#define O_RW 0666
int main(int argc, chat * argv[])
{
  int fdOld, fdNew, count;
  char buffer[2048];
  fdOld = open(argv[1], O_RDONLY);
  fdNew = creat(argv[2], O_RW);
  while(count = read(fdOld, buffer, sizeof(buffer)))
  {
    write(fdNew, buffer, count);
  }
  close(fdOld);
  close(fdNew);
}
```

+ 直接调用

```c++
#include<unistd.h>
#include <sys/syscall.h>
#define O_RDONLY 00
#define O_RW 0666
int mian(int argc, char * argv[])
{
  int fdOld, fdNew, count;
  char buffer[2048];
  fdOld = syscall(SYS_open, argv[1], O_RDONLY);
  fdNew = syscall(SYS_creat, argv[2], 0666);
  while(count = syscall(SYS_read, fdOld, buffer, sizeof(buffer)))
  {
    syscall(SYS_write, fdNew, buffer, count);
  }
  syscall(SYS_close, fdOld);
  syscall(SYS_close, fdNew);
}
// SYS_open 系统调用号
// syscall()  系统调用入口 
```

![image-20201005214657593](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201005214657593.png)



+ 系统调用一般的处理

> 处理机的状态由用户态 ----> 系统态
>
> 保护CPU现场 将PSW, PC 系统调用号， 用户栈指针， 通用寄存器压入堆栈
>
> 用户的参数送到指定的位置
>
> 中断表和陷入向量表



## 操作系统引导(启动模块)



![image-20201005223006371](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201005223006371.png)

ROM BIOS 自检， 然后调用19中断转入引导程序



##### 系统启动过程

机器加电 ---> BIOS 加电自检 进行硬件检测 --->  读入启动盘的引导扇区 512字节到内存 0000:7C00出 ----> 检查内存0000:7DFE~7DFF 是否为0x55AA ---> 跳转到0000:7C00执行引导记录程序

##### 引导扇区

末字节为0x55AA

#### 操作系统二次加载引导程序

BIOS加载引导程序 --> 引导程序加载内核的代码

##### 二次加载

+ BIOS将引导程序载入内存执行
+ 引导程序讲操作系统载入内存
+ 软驱的复位和读取 (读取的内核代码) BIOS INT 13H 
+ BIOS INT 10H 字符串的显示

注：'$'程序的当前地址 '$$' 程序的起始地址



## 操作系统的发展动力



+ 硬件（提高资源利用率和系统性能）
+ 方便用户
+ 适应器件的更新的换代
+ 计算机的体系结构不断发展

### 发展

+ 人工阶段 纸带/卡片 机器语言 拥堵独占 资源利用率低 CPU大量时间空闲
+ 为了解决人机矛盾  通道技术 中断技术 缓冲技术 脱机输入输出 批处理技术





## 单道批处理



+ 脱机的形式输入到磁带上， 在系统配置的**监控程序**控制下一个一个的自动一次连续处理（操作系统的萌芽）

+ 内存中始终保留着一道作业（内存有限，只有一道程序在内存中）

  

![image-20201006153315045](https://cdn.jsdelivr.net/gh/Diamond-Au/image/image/image-20201006153315045.png)

+ 特征： 自动（没有干预性），顺序（加载顺序一样）， 单道性（独占， 利用率低） 



## 多道批处理



+ 单道批处理系统资源闲置
+ 多道程序：同时调入多道作业
+ 交替使用CPU 作业后备队列/作业调度算法/系统资源共享
+ CPU  I/O利用率提高
+ 系统的吞吐量增加

### 特点

+ 多道性 并发执行
+ 无序性
+ 调度性 作业调度（外存 ---> 内存的选取装入） 进程调度(内存--->处理器调度)

### 优缺点

+ 系统资源利用率高
+ 吞吐量大
+ 作业平均周转时间长， 短作业不公平
+ 无交互能力



## 形成了系统的需求



#### 处理机管理问题

- 分配共享的处理机，使处理机正常利用，分配和回收

#### 内存管理问题

+ 内存分配和保护

#### I/O管理问题

+ 设备共享，分配和利用

#### 文件管理

+ 文件组织和方便用户使用
+ 文件数据的安全性和一致性

#### 作业调度

+ 作业调度问题

形成了操作系统的基本框架雏形



## 操作系统的分支



### 分时系统

+ 交互性
+ 共享主机
+ 便于用户上机
+ 一台主机，多个终端，用户可以同时使用
+ 及时接受用户的命令和数据（多路的缓冲区）
+ 及时处理反馈（所有的用户作业全部装入内存， 在不长的时间里是每个作业运行一次）



#### 实现方式

+ 时间片轮转策略
+ 作业直接进入内存



#### 特征

+ 多路性 宏观多个用户同时工作共享资源，微观每个用户运行一个时间片
+ 独立性 每个人一个终端
+ 及时性
+ 交互性



### 实时系统

+ 规定的时间内完成处理，及时的响应

+ 系统的高度可靠



## 操作系统的处理器管理



#### 处理器的调度(进程)

> 作业装入内存之后，建立起后备队列，进行资源的选择和分配，同时要建立起相对应的进程管理，当就绪进程队列建立起，就要进行进程的选择和调度，同时还要运行和保护现场，根据进程的优先级不一样，分为**先来先服务算法**,  **优先权高者优先调度算法**



#### 进程控制

+ 创建 撤销，状态转换



#### 进程同步

+ 临界资源的管理（互斥）

+ 线程之间的协作



## 进程通信



+ 共享存储器
+ 管道
+ 消息传递系统 消息队列 邮箱



## 内存管理



#### 内存分配

+ 用数据结构记录内存信息
+ 连续/离散
+ 静态/动态

#### 内存回收

#### 内存保护

+ 越界检查

#### 地址映射

#### 内存扩充



## 设备管理



#### 设备分配





